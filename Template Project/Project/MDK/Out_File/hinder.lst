C251 COMPILER V5.60.0,  hinder                                                             11/10/23  16:55:29  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE hinder
OBJECT MODULE PLACED IN .\Out_File\hinder.obj
COMPILER INVOKED BY: D:\Software\Keil_v5\C251\BIN\C251.EXE ..\USER\src\hinder.c XSMALL UNSIGNED_CHAR WARNINGLEVEL(3) BRO
                    -WSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\U
                    -SER\inc;..\USER\src) DEBUG PRINT(.\Out_File\hinder.lst) OBJECT(.\Out_File\hinder.obj) 

stmt  level    source

    1          /* Includes ------------------------------------------------------------------*/
    2          #include "hinder.h"
    3          #include "control.h"
    4          #include "car.h"
    5          /* Includes ------------------------------------------------------------------*/
    6          
    7          /****************************************************
    8           * @name              hinder_parameter_init
    9           * @function      障碍物初始化参数
   10           * @parameter     NULL
   11           * @return                NULL
   12           * @date                  2023/7/27
   13           ***************************************************/
   14           void hinder_parameter_init(){
   15   1       
   16   1               //使能标记位置
   17   1              car.hinder.enable_flag                     = 0;
   18   1              //障碍状态
   19   1              car.hinder.state                           = 0;
   20   1      
   21   1              //初始距离
   22   1              car.hinder.distance                        = 100000;
   23   1      
   24   1              //识别障碍物距离
   25   1              car.hinder.judge_distance                  = 950;
   26   1      
   27   1              //识别障碍物速度
   28   1              car.hinder.speed                           = 250;
   29   1      
   30   1              //识别障碍物陀螺仪角度
   31   1              car.hinder.gyro_kp                         = 0;  
   32   1              
   33   1              //状态1拐点转角和前进距离
   34   1              car.hinder.point_1.angle                   = 50;  
   35   1              car.hinder.point_1.distance                = 10; 
   36   1      
   37   1              //状态2拐点转角和前进距离
   38   1              car.hinder.point_2.angle                   = 100;  
   39   1              car.hinder.point_2.distance                = 40;
   40   1      
   41   1              //临时赋值
   42   1              car.hinder.enter_angle                     = 0;
   43   1      
   44   1              //第一段惯性导航半径
   45   1              car.hinder.R_circle                        = 35;
   46   1      
   47   1              //第二段惯性导航半径
   48   1              car.hinder.R_circle_2                      = 50;
   49   1      
   50   1              //电感条件数值
   51   1              car.hinder.adc                             = 50;
   52   1               
   53   1              //避障方向
   54   1              car.hinder.dir                             = LEFT;
   55   1              
   56   1              //避障次数
   57   1              car.hinder.count                           = RIGHT;
C251 COMPILER V5.60.0,  hinder                                                             11/10/23  16:55:29  PAGE 2   

   58   1       }
   59          /****************************************************
   60           * @name              hinder_judge
   61           * @function      障碍检测条件
   62           * @parameter     NULL
   63           * @return                NULL
   64           * @date                  2023/7/6
   65           ***************************************************/
   66          void hinder_judge()
   67          {
   68   1              static int count_hinder =0;
   69   1              dl1a_get_distance();//读取距离
   70   1              if(dl1a_finsh_flag == 1)//判断数据是否有效
   71   1              {
   72   2                      car.hinder.distance = dl1a_distance_mm;
   73   2              }
   74   1              if(car.hinder.distance<car.hinder.judge_distance){//距离条件
   75   2                  BEEP_ON;
   76   2                              count_hinder++;
   77   2                              car.road_type = HINDER;
   78   2                              car.hinder.enter_angle = icmdata.Yaw;
   79   2                              car.hinder.initial_angle = icmdata.Yaw;
   80   2                              //car.hinder.enable_flag = 1;
   81   2                              car.hinder.count++;
   82   2                              
   83   2              }
   84   1      }
   85          /****************************************************
   86           * @name            turn_angle
   87           * @function    expect_angle: 期望角度
   88                                          current_angle:实际角度
   89                                          speed：       速度
   90                                          R_circle:     转弯半径
   91           * @parameter   NULL
   92           * @return              NULL
   93           * @date                2023/7/10
   94           ***************************************************/
   95           void turn_angle(float expect_angle,float current_angle,float speed,float R_circle)
   96           {
   97   1               static int count = 0;
   98   1               static float w = 0 ;
   99   1               static float diff_angle;
  100   1      
  101   1                      if(count>=3){
  102   2                              diff_angle=expect_angle-current_angle;
  103   2                              count= 0 ;
  104   2                      }
  105   1              
  106   1                      count++;
  107   1                      car.pd_loop.expected = car.pd_loop.circle_p*diff_angle;
  108   1      
  109   1                      w = my_abs(speed/R_circle)*57.3;
  110   1                      if(car.pd_loop.expected > w )      car.pd_loop.expected = w;
  111   1                      else if(car.pd_loop.expected < -w )car.pd_loop.expected = -w;
  112   1                      // //内环
  113   1                      car.pd_loop.current  = icmdata.YawVelocity;
  114   1                      if(car.start_flag==START)
  115   1                      {       
  116   2                      Incremental_PID_Caculate(&car.pd_loop);//增量式pid
  117   2                       car.steering.duty    = car.pd_loop.duty;
  118   2                       }      
  119   1              //转向PWM限幅
  120   1              if(car.steering.duty>300)      car.steering.duty = 300;
  121   1              else if(car.steering.duty<-300)car.steering.duty =-300;
  122   1       }
  123           
C251 COMPILER V5.60.0,  hinder                                                             11/10/23  16:55:29  PAGE 3   

  124          /****************************************************
  125           * @name              hinder_control
  126           * @function      障碍物状态机  
  127           * @parameter     NULL
  128           * @return                NULL
  129           * @date                  2023/7/6
  130           ***************************************************/
  131          void hinder_control()
  132          {
  133   1              static int DIR;
  134   1              //左避障
  135   1              if(car.hinder.dir==LEFT)
  136   1              {
  137   2                      DIR=1;
  138   2              } 
  139   1              //右避障
  140   1                      if(car.hinder.dir==RIGHT)
  141   1              {
  142   2                      DIR=-1;
  143   2              }
  144   1      
  145   1              switch (car.hinder.state)
  146   1                      {
  147   2                       /***********************状态0：左转打角圆弧*************************/
  148   2                              case 0:/***逆时针：正数*******/
  149   2                              turn_angle(DIR*car.hinder.point_1.angle,icmdata.Yaw-car.hinder.enter_angle,car.hinder.speed,car.hinder
             -.R_circle);
  150   2                              motor_control(car.hinder.speed-car.steering.duty,car.hinder.speed+car.steering.duty);           
  151   2                              if(my_abs(icmdata.Yaw-car.hinder.enter_angle)>car.hinder.point_1.angle*0.9){
  152   3                                      car.hinder.state = 1;
  153   3                                      car.hinder.point = car.distance;
  154   3                                  car.hinder.enter_angle = icmdata.Yaw;
  155   3                              }
  156   2                              break;
  157   2                       /***********************状态0：左转打角圆弧*************************/
  158   2      
  159   2      
  160   2                      /************************状态1：前进一段距离*************************/
  161   2                              case 1:
  162   2                              motor_control(car.hinder.speed,car.hinder.speed);
  163   2                              if(my_abs(car.distance-car.hinder.point)>car.hinder.point_1.distance){
  164   3                                      car.hinder.state = 2;
  165   3                                      car.hinder.enter_angle = icmdata.Yaw;
  166   3                              }
  167   2                              break;
  168   2                      /************************状态1：前进一段距离*************************/
  169   2      
  170   2      
  171   2                      /************************状态2：右转打角圆弧*************************/
  172   2                              case 2:
  173   2                         turn_angle((-DIR)*car.hinder.point_2.angle,icmdata.Yaw-car.hinder.enter_angle,150,car.hinder.R_circl
             -e_2);
  174   2                              motor_control(car.hinder.speed-car.steering.duty,car.hinder.speed+car.steering.duty);   
  175   2                              if(my_abs(icmdata.Yaw-car.hinder.enter_angle)>car.hinder.point_2.angle*0.7){
  176   3                                      car.hinder.state= 3;
  177   3                                      car.hinder.enter_angle = icmdata.Yaw;
  178   3                                      car.hinder.point = car.distance;
  179   3                              }
  180   2                              break;
  181   2                      /***********************状态2：右转打角圆弧***************************/
  182   2                              
  183   2      
  184   2                      /***********************状态3：前进一段距离****************************/
  185   2                              case 3:
  186   2                              motor_control(car.hinder.speed,car.hinder.speed);
  187   2                               if(my_abs(car.distance-car.hinder.point)>car.hinder.point_2.distance)
C251 COMPILER V5.60.0,  hinder                                                             11/10/23  16:55:29  PAGE 4   

  188   2                               {      
  189   3                                      car.hinder.state = 4;                   
  190   3                               }      
  191   2                              break;
  192   2                      /***********************状态3：前进一段距离****************************/
  193   2      
  194   2                      /***********************状态4：转弯打角*******************************/
  195   2                              case 4:
  196   2                              turn_angle(DIR*car.hinder.point_1.angle,icmdata.Yaw-car.hinder.enter_angle,car.hinder.speed,30);
  197   2                              motor_control(car.hinder.speed-car.steering.duty,car.hinder.speed+car.steering.duty);   
  198   2                              if((my_abs(icmdata.Yaw-car.hinder.enter_angle)>car.hinder.point_1.angle*0.9)||(my_abs(icmdata.Yaw-car.
             -hinder.initial_angle)<10))
  199   2                              {
  200   3                                        car.hinder.state = 5;
  201   3                                        car.hinder.point = car.distance;
  202   3                                  car.hinder.enter_angle = icmdata.Yaw;
  203   3                              }
  204   2                              break;
  205   2                      /***********************状态4：转弯打角*******************************/
  206   2      
  207   2                      /***********************状态5：转弯***********************************/
  208   2                              case 5:
  209   2                      error_calculate(5+0.7*(car.distance-car.hinder.point),0.3+0.015*(car.distance-car.hinder.point));
  210   2                              motor_control(car.straight.base_speed-car.steering.duty,car.straight.base_speed+car.steering.duty);
  211   2                              if(car.distance-car.hinder.point>30)
  212   2                              {
  213   3                              car.hinder.state = 6;
  214   3                              }
  215   2                              break;
  216   2                      /***********************状态5：转弯***********************************/
  217   2      
  218   2      
  219   2                      /***********************状态4：切换直道*******************************/
  220   2                              case 6:
  221   2                              car.hinder.state = 0;
  222   2                              car.road_type = STRAIGHT;
  223   2                              car.hinder.distance = 100000;
  224   2                              car.element.ELEMENT_NUM++;      //元素表个数加1
  225   2                              BEEP_OFF;
  226   2                              break;
  227   2                      /***********************状态4：切换直道*******************************/
  228   2              }
  229   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1244     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        14          8
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        20     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
