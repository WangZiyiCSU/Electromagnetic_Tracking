C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE isr
OBJECT MODULE PLACED IN .\Out_File\isr.obj
COMPILER INVOKED BY: D:\Software\Keil_v5\C251\BIN\C251.EXE ..\USER\src\isr.c XSMALL UNSIGNED_CHAR WARNINGLEVEL(3) BROWSE
                    - INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER
                    -\inc;..\USER\src) DEBUG PRINT(.\Out_File\isr.lst) OBJECT(.\Out_File\isr.obj) 

stmt  level    source

    1          #include "zf_uart.h"
    2          #include "headfile.h"
    3          #include "control.h"
    4          #include "car.h"
    5          #include "garage.h"
    6          
    7          #define PI 3.1415926
    8          extern void pit_handler(void);
    9          void TM4_Isr() interrupt 20 
   10          {
   11   1              static int dutyerror=0;
   12   1              static int lose = 0;
   13   1              static float temp_error=0;
   14   1              static int count = 0;
   15   1              static int count_10ms = 0;
   16   1              static int count_2s = 0;
   17   1          static int type_temp = 0;
   18   1              TIM4_CLEAR_FLAG; //Çå³ýÖÐ¶Ï±êÖ¾
   19   1              //pit_handler();
   20   1      //      if(USART4_RX_LEN > 0 )return;
   21   1      //      USART4_RX_STA = REFUSE_TO_RECEIVE;
   22   1              
   23   1      
   24   1              switch(car.work_mode)
   25   1              {
   26   2                      case NORMAL:    //ÆÕÍ¨Ñ°¼£Ä£Ê½
   27   2                      {
   28   3                              Normal_Tracing(); //ÆÕÍ¨ÈüµÀÑ°¼£
   29   3                              break;
   30   3                      }
   31   2                      case SCAN:              //É¨ÃèÈüµÀÄ£Ê½
   32   2                      {
   33   3                              //AD_Scan(&car.adc_parameter);  //É¨ÃèÈüµÀµÃ¸÷¸öµç¸Ð×î´óÖµ
   34   3                              break;
   35   3                      }
   36   2                      case TEST:
   37   2                      {
   38   3      
   39   3                              //µç¸ÐÊý¾Ý²É¼¯
   40   3                               ADC_Process(&car.adc_parameter);          //¾ùÖµÂË²¨
   41   3                               ADC_Normalization(&car.adc_parameter); //¹éÒ»»¯ 0-100
   42   3                              // //ÍÓÂÝÒÇÊý¾Ý²É¼¯
   43   3                               ICM_OneOrderFilter();   
   44   3      //               pwm_duty(PWMB_CH4_P77, 600);                                           
   45   3      //               pwm_duty(PWMB_CH3_P33, 600); 
   46   3                               //hinder_judge(); 
   47   3                               //CitTie_judge();     
   48   3                              // //µç¸ÐÆ«²î¼ÆËã
   49   3                              //get_error_normal(&car.adc_parameter); //¼ÆËãÆ«²î      
   50   3                              // car.steering.error_now = car.adc_parameter.adc_error ;
   51   3                              // //·½Ïò»·¼ÆËã 
   52   3                              // car.steering.duty = car.steering.linear_error_kp   *car.steering.error_now +                                                         //Ò»´ÎÆ«²î  
             - 
   53   3                              //                                  car.steering.quadratic_error_kp*car.steering.error_now*abs(car.steering.error_now) +    //¶
             -þ´ÎÆ«²î
   54   3                              //                                  car.steering.error_kd*(car.steering.error_now - car.steering.error_last) -                      //Æ«²î²î·
             -Ö
C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 2   

   55   3                              //                                  car.steering.gyro_kp *icmdata.YawVelocity;                                                                                          //ÍÓÂÝÒÇÒÖÖÆ
   56   3                              // car.steering.error_last = car.steering.error_now;
   57   3                              // //×ªÏòPWMÏÞ·ù
   58   3                              // if(car.steering.duty>MOTOR_DUTY_MAX)car.steering.duty=MOTOR_DUTY_MAX;
   59   3                              // else if(car.steering.duty<-MOTOR_DUTY_MAX)car.steering.duty=-MOTOR_DUTY_MAX;
   60   3                              // //µç»ú¿ØËÙ
   61   3                              // //ËÙ¶È²âÁ¿
   62   3                               EncoderPulseGet(); 
   63   3                              //motor_control(-250,-150);//±Õ»·ËÙ¶È150
   64   3                              //Stop_after(2);
   65   3                              // MotorPWM_Out(car.motor_average.duty, car.motor_average.duty);
   66   3                              //MotorPWM_Out(1000,2000);
   67   3                              // if(car.distance>100){
   68   3                              //      block_judge();
   69   3                              // }
   70   3                              
   71   3      
   72   3                              break;
   73   3                      }
   74   2                      case REMOTE:    //Ò£¿ØÄ£Ê½
   75   2                      {
   76   3                              break;
   77   3                      }
   78   2              }
   79   1      
   80   1      //    if(type_temp != car.road_type)
   81   1      //        {
   82   1      //            ips114_clear(WHITE);
   83   1      //            type_temp = car.road_type;
   84   1      //            switch(car.road_type)
   85   1      //            {
   86   1      //                      case OUT_GARAGE:
   87   1      //                ips114_showstr(0, 0, "³ö¿â\n");
   88   1      //                              break;  
   89   1      //                      case STRAIGHT :                 
   90   1      //                ips114_showstr(0, 0, "Ö±µÀ\n");
   91   1      //                              break;  
   92   1      //                      case CIRCLE:
   93   1      //                ips114_showstr(0, 0, "»·µº\n");
   94   1      //                              break;  
   95   1      ////                    case FORK :
   96   1      ////                            //printf("chaÂ·\n");
   97   1      ////                            break;  
   98   1      ////                    case STRAIGHT_FORK:
   99   1      ////                            //printf("chaÂ·ÄÚ\n");
  100   1      ////                            break;  
  101   1      //                      case ENTER_GARAGE :
  102   1      //                ips114_showstr(0, 0, "Èë¿â\n");
  103   1      
  104   1      //                              break;  
  105   1      ////                    case CROSS :
  106   1      ////                            //printf("Ê®×Ö\n");
  107   1      ////                            break;  
  108   1      //                      case RAMP:
  109   1      //                ips114_showstr(0, 0, "ÆÂµÀ\n");
  110   1      //                              break;  
  111   1      //            }
  112   1      //        }
  113   1      
  114   1              //¸üÐÂ±êÖ¾Î» ÓÃÓÚÆÁÄ»¶¨Ê±Ë¢ÐÂ
  115   1              if(car.screen.ready==0)
  116   1              {
  117   2                      car.screen.count++;
  118   2                      if(car.screen.count >= 200/car.screen.fps)
  119   2                      {
  120   3                              car.screen.count = 0;
C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 3   

  121   3                              car.screen.ready = 1;
  122   3                      }
  123   2              }
  124   1      //      USART4_RX_STA = EMPTY;
  125   1      }
  126          
  127          //UART1ÖÐ¶Ï
  128          void UART1_Isr() interrupt 4
  129          {
  130   1          uint8 res;
  131   1              static uint8 dwon_count;
  132   1          if(UART1_GET_TX_FLAG)
  133   1          {
  134   2              UART1_CLEAR_TX_FLAG;
  135   2              busy[1] = 0;
  136   2          }
  137   1          if(UART1_GET_RX_FLAG)
  138   1          {
  139   2              UART1_CLEAR_RX_FLAG;
  140   2              res = SBUF;
  141   2              //³ÌÐò×Ô¶¯ÏÂÔØ
  142   2              if(res == 0x7F)
  143   2              {
  144   3                  if(dwon_count++ > 20)
  145   3                      IAP_CONTR = 0x60;
  146   3              }
  147   2              else
  148   2              {
  149   3                  dwon_count = 0;
  150   3              }
  151   2          }
  152   1      }
  153          
  154          //UART2ÖÐ¶Ï
  155          void UART2_Isr() interrupt 8
  156          {
  157   1          if(UART2_GET_TX_FLAG)
  158   1              {
  159   2              UART2_CLEAR_TX_FLAG;
  160   2                      busy[2] = 0;
  161   2              }
  162   1          if(UART2_GET_RX_FLAG)
  163   1              {
  164   2              UART2_CLEAR_RX_FLAG;
  165   2                      //½ÓÊÕÊý¾Ý¼Ä´æÆ÷Îª£ºS2BUF
  166   2      
  167   2              }
  168   1      }
  169          
  170          
  171          //UART3ÖÐ¶Ï
  172          void UART3_Isr() interrupt 17
  173          {
  174   1          if(UART3_GET_TX_FLAG)
  175   1              {
  176   2              UART3_CLEAR_TX_FLAG;
  177   2                      busy[3] = 0;
  178   2              }
  179   1          if(UART3_GET_RX_FLAG)
  180   1              {
  181   2              UART3_CLEAR_RX_FLAG;
  182   2                      //½ÓÊÕÊý¾Ý¼Ä´æÆ÷Îª£ºS3BUF
  183   2      
  184   2              }
  185   1      }
  186          
C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 4   

  187          
  188          //UART4ÖÐ¶Ï
  189          void UART4_Isr() interrupt 18
  190          {
  191   1          if(UART4_GET_TX_FLAG)
  192   1              {
  193   2              UART4_CLEAR_TX_FLAG;
  194   2                      busy[4] = 0;
  195   2              }
  196   1          if(UART4_GET_RX_FLAG)
  197   1              {
  198   2              UART4_CLEAR_RX_FLAG;
  199   2      
  200   2                      //½ÓÊÕÊý¾Ý¼Ä´æÆ÷Îª£ºS4BUF;
  201   2                      if(wireless_type == WIRELESS_SI24R1)
  202   2              {
  203   3                  wireless_uart_callback();           //ÎÞÏß×ª´®¿Ú»Øµ÷º¯Êý
  204   3              }
  205   2              else if(wireless_type == WIRELESS_CH9141)
  206   2              {
  207   3                  bluetooth_ch9141_uart_callback();   //À¶ÑÀ×ª´®¿Ú»Øµ÷º¯Êý
  208   3              }
  209   2              else if(wireless_type == WIRELESS_CH573)
  210   2              {
  211   3                  wireless_ch573_callback();          //CH573ÎÞÏßÄ£¿é»Øµ÷º¯Êý
  212   3              }
  213   2              }
  214   1      }
  215          
  216          void INT1_Isr() interrupt 2
  217          {
  218   1      
  219   1      }
  220          void INT2_Isr() interrupt 10
  221          {
  222   1              INT2_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  223   1      }
  224          void INT3_Isr() interrupt 11
  225          {
  226   1              INT3_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  227   1      }
  228          
  229          void INT4_Isr() interrupt 16
  230          {
  231   1              INT4_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  232   1      }
  233          
  234          void TM0_Isr() interrupt 1
  235          {
  236   1      
  237   1      }
  238          void TM1_Isr() interrupt 3
  239          {
  240   1      
  241   1      }
  242          void TM2_Isr() interrupt 12
  243          {
  244   1              TIM2_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  245   1              
  246   1      }
  247          void TM3_Isr() interrupt 19
  248          {
  249   1              TIM3_CLEAR_FLAG; //Çå³ýÖÐ¶Ï±êÖ¾
  250   1              
  251   1      }
  252          
C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 5   

  253          ////UART4ÖÐ¶Ï
  254          //void UART4_Isr() interrupt 18
  255          //{
  256          
  257          ////    uint8 res;
  258          ////    if(UART4_GET_TX_FLAG)
  259          ////    {
  260          ////            UART4_CLEAR_TX_FLAG;
  261          ////            busy[4] = 0;
  262          ////    }
  263          ////    if(UART4_GET_RX_FLAG)
  264          ////    {
  265          ////        UART4_CLEAR_RX_FLAG;
  266          ////            res = WIRELESS_DATA_BUF;
  267          ////            if(USART4_RX_STA == EMPTY)
  268          ////            {
  269          ////                    uart4_rx_buff[USART4_RX_LEN++] = res;
  270          ////                    USART4_RX_STA = RECEIVING;
  271          ////            }
  272          ////            else if(USART4_RX_STA == RECEIVING)
  273          ////            {
  274          ////                    uart4_rx_buff[USART4_RX_LEN++] = res;
  275          ////                    if(uart4_rx_buff[USART4_RX_LEN-1]==0x0a)
  276          ////                    {
  277          ////                            if(USART4_RX_LEN>=2 && uart4_rx_buff[USART4_RX_LEN-2]==0x0d )
  278          ////                            {
  279          ////                                    USART4_RX_STA = RECEIVING_COMPLETED;
  280          ////                            }
  281          ////                    }
  282          ////            }
  283          ////    }
  284          //}
  285          //      
  286          
  287          
  288          
  289          
  290          
  291          
  292          
  293          
  294          
  295          
  296          
  297          ////UART1ÖÐ¶Ï
  298          //void UART1_Isr() interrupt 4
  299          //{
  300          //    uint8 res;
  301          //      static uint8 dwon_count;
  302          //    if(UART1_GET_TX_FLAG)
  303          //    {
  304          //        UART1_CLEAR_TX_FLAG;
  305          //        busy[1] = 0;
  306          //    }
  307          //    if(UART1_GET_RX_FLAG)
  308          //    {
  309          //        UART1_CLEAR_RX_FLAG;
  310          //        res = SBUF;
  311          //        //³ÌÐò×Ô¶¯ÏÂÔØ
  312          //        // if(res == 0x7F)
  313          //        // {
  314          //        //     if(dwon_count++ > 20)
  315          //        //         IAP_CONTR = 0x60;
  316          //        // }
  317          //        // else
  318          //        // {
C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 6   

  319          //        //     dwon_count = 0;
  320          //        // }
  321          ////    
  322          ////            if((USART_RX_STA&0x8000) == 0){//½ÓÊÕÎ´Íê³É
  323          ////                            if(USART_RX_STA<(UART1_RX_BUFFER_SIZE)){
  324          ////                                      TL1 = 0x00;
  325          ////                                            TH1 = 0x00;
  326          ////                                            if(USART_RX_STA == 0){
  327          ////                                                    pit_timer_ms(TIM_1, 10); //´ò¿ª¶¨Ê±Æ÷3
  328          ////                                            }
  329          ////                                            uart1_rx_buff[USART_RX_STA++]=res;//¼ÇÂ¼½ÓÊÕµ½µÄÖµ
  330          ////                            }
  331          ////                            else{
  332          ////                                    USART_RX_STA|=0x8000; //³¬³ö»º´æÈÝÁ¿ Ç¿ÖÆ±ê¼ÇÎª½ÓÊÕÍê³É
  333          ////                            }       
  334          ////            }
  335          //      }
  336          //}
  337          
  338          ////UART2ÖÐ¶Ï
  339          //void UART2_Isr() interrupt 8
  340          //{
  341          //    if(UART2_GET_TX_FLAG)
  342          //      {
  343          //        UART2_CLEAR_TX_FLAG;
  344          //              busy[2] = 0;
  345          //      }
  346          //    if(UART2_GET_RX_FLAG)
  347          //      {
  348          //        UART2_CLEAR_RX_FLAG;
  349          //              //½ÓÊÕÊý¾Ý¼Ä´æÆ÷Îª£ºS2BUF
  350          
  351          //      }
  352          //}
  353          
  354          ////UART3ÖÐ¶Ï
  355          //void UART3_Isr() interrupt 17
  356          //{
  357          //    if(UART3_GET_TX_FLAG)
  358          //      {
  359          //        UART3_CLEAR_TX_FLAG;
  360          //              busy[3] = 0;
  361          //      }
  362          //    if(UART3_GET_RX_FLAG)
  363          //      {
  364          //        UART3_CLEAR_RX_FLAG;
  365          //              //½ÓÊÕÊý¾Ý¼Ä´æÆ÷Îª£ºS3BUF
  366          
  367          //      }
  368          //}
  369          //      
  370          
  371          //              
  372          //      
  373          
  374          
  375          //void INT0_Isr() interrupt 0
  376          //{
  377          //      INT0_CLEAR_FLAG;
  378          
  379          //}
  380          
  381          
  382          
  383          //void INT1_Isr() interrupt 2
  384          //{
C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 7   

  385          //      static int back = 0;
  386          //      INT1_CLEAR_FLAG;
  387          
  388          
  389          //}
  390          ////Íâ²¿ÖÐ¶Ï2  
  391          //void INT2_Isr() interrupt 10
  392          //{
  393          //      INT2_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  394          
  395          //}
  396          
  397          //void INT3_Isr() interrupt 11
  398          //{
  399          //      INT3_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  400          //}
  401          
  402          //void INT4_Isr() interrupt 16
  403          //{
  404          //      INT4_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  405          //}
  406          
  407          //void TM0_Isr() interrupt 1  //ÎÞ·¨Ê¹ÓÃ ¶¨Ê±Æ÷0ÒÑÓÃÓÚ±àÂëÆ÷Íâ²¿¼ÆÊý
  408          //{
  409          //      
  410          //}
  411          
  412          //void TM1_Isr() interrupt 3     //ÓÃÓÚÍ¨ÐÅÍê³ÉÅÐ¶Ï
  413          //{
  414          ////    static int count = 0;
  415          ////    count++;
  416          ////    if(count >= 50){
  417          ////            count = 0;
  418          ////            USART_RX_STA |=0x8000;          //±ê¼Ç½ÓÊÕÍê³É
  419          ////            USART4_RX_STA |=0x8000;         //±ê¼Ç½ÓÊÕÍê³É
  420          ////            car.uart_busy = 0;
  421          ////            TR1 = 0; //¹Ø±Õ¶¨Ê±Æ÷
  422          ////    }
  423          //}
  424          
  425          //void TM2_Isr() interrupt 12  //ÓÃÓÚ´®¿Ú4µÄ²¨ÌØÂÊ²úÉú
  426          //{
  427          //      TIM2_CLEAR_FLAG;  //Çå³ýÖÐ¶Ï±êÖ¾
  428          //}
  429          
  430          //void TM3_Isr() interrupt 19 //ÎÞ·¨Ê¹ÓÃ ¶¨Ê±Æ÷3ÒÑÓÃÓÚ±àÂëÆ÷Íâ²¿¼ÆÊý
  431          //{
  432          //      TIM3_CLEAR_FLAG; //Çå³ýÖÐ¶Ï±êÖ¾
  433          //}
  434          ////extern void pit_handler(void);
  435          ////void TM4_Isr() interrupt 20
  436          ////{
  437          ////    TIM4_CLEAR_FLAG; //Çå³ýÖÐ¶Ï±êÖ¾
  438          //////  ccd_collect();   //CCD²É¼¯Êý¾Ý
  439          
  440          ////    pit_handler();
  441          ////}
  442          
  443          
  444          
  445          
  446          
  447          
  448          
  449          //void  INT0_Isr()  interrupt 0;
  450          //void  TM0_Isr()   interrupt 1;
C251 COMPILER V5.60.0,  isr                                                                11/10/23  16:55:26  PAGE 8   

  451          //void  INT1_Isr()  interrupt 2;
  452          //void  TM1_Isr()   interrupt 3;
  453          //void  UART1_Isr() interrupt 4;
  454          //void  ADC_Isr()   interrupt 5;
  455          //void  LVD_Isr()   interrupt 6;
  456          //void  PCA_Isr()   interrupt 7;
  457          //void  UART2_Isr() interrupt 8;
  458          //void  SPI_Isr()   interrupt 9;
  459          //void  INT2_Isr()  interrupt 10;
  460          //void  INT3_Isr()  interrupt 11;
  461          //void  TM2_Isr()   interrupt 12;
  462          //void  INT4_Isr()  interrupt 16;
  463          //void  UART3_Isr() interrupt 17;
  464          //void  UART4_Isr() interrupt 18;
  465          //void  TM3_Isr()   interrupt 19;
  466          //void  TM4_Isr()   interrupt 20;
  467          //void  CMP_Isr()   interrupt 21;
  468          //void  I2C_Isr()   interrupt 24;
  469          //void  USB_Isr()   interrupt 25;
  470          //void  PWM1_Isr()  interrupt 26;
  471          //void  PWM2_Isr()  interrupt 27;


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       406     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        17     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        44     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
